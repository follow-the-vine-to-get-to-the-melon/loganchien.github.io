<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Logan's Note</title><link href="https://loganchien.github.io/" rel="alternate"></link><link href="https://loganchien.github.io/feeds/web.atom.xml" rel="self"></link><id>https://loganchien.github.io/</id><updated>2014-11-24T23:32:00+08:00</updated><entry><title>Let's Encrypt</title><link href="https://loganchien.github.io/posts/2014/11/24/lets-encrypt/" rel="alternate"></link><updated>2014-11-24T23:32:00+08:00</updated><author><name>Logan</name></author><id>tag:loganchien.github.io,2014-11-24:posts/2014/11/24/lets-encrypt/</id><summary type="html">&lt;p&gt;According to the &lt;a class="reference external" href="http://andreasgal.com/2014/11/18/lets-encrypt-one-more-step-on-the-road-to-tls-everywhere/"&gt;post&lt;/a&gt; by &lt;a class="reference external" href="http://andreasgal.com"&gt;Andreas Gal&lt;/a&gt;, &lt;a class="reference external" href="https://www.eff.org/"&gt;EFF&lt;/a&gt;, &lt;a class="reference external" href="https://mozilla.com/"&gt;Mozilla&lt;/a&gt;, Cisco, Akamai,
and IdenTrust are going to form Internet Security Research Group which will
start the &lt;a class="reference external" href="https://letsencrypt.org/"&gt;Let's Encrypt&lt;/a&gt; ceritificate authority service in 2015 Q2.&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="https://letsencrypt.org/"&gt;Let's Encrypt&lt;/a&gt; is expected to become a free, automated, and open SSL
sertificate authority which aims to increase the adoption of HTTPS protocol
and provide a more secure Internet.  I am looking forward to this project.&lt;/p&gt;
&lt;p&gt;For the impatient, you may check &lt;a class="reference external" href="https://github.com/letsencrypt"&gt;their GitHub&lt;/a&gt; for the preview release.&lt;/p&gt;
</summary><category term="http"></category><category term="ssl"></category></entry><entry><title>GitHub Pages and HTTPS</title><link href="https://loganchien.github.io/posts/2014/11/16/github-pages-and-https/" rel="alternate"></link><updated>2014-11-16T23:31:00+08:00</updated><author><name>Logan</name></author><id>tag:loganchien.github.io,2014-11-16:posts/2014/11/16/github-pages-and-https/</id><summary type="html">&lt;p&gt;&lt;a class="reference external" href="https://pages.github.com"&gt;GitHub Pages&lt;/a&gt; supports HTTPS protocol.  It will be good to prefer HTTPS to
HTTP.  However, I found that if the URLs are not written carefully, the
user might be redirected to HTTP URLs.&lt;/p&gt;
&lt;p&gt;For unknown reason, &lt;a class="reference external" href="https://pages.github.com"&gt;GitHub Pages&lt;/a&gt; are redirecting the directories without
trailing slash to the HTTP URLs.  For example, the following URL:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
https://loganchien.github.io/cert
&lt;/pre&gt;
&lt;p&gt;will be redirected to:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
http://loganchien.github.io/cert/
&lt;/pre&gt;
&lt;p&gt;To avoid this pitfall, please make sure that your URLs are ending with trailing
slash if they are pointing to directories.  For example,&lt;/p&gt;
&lt;pre class="code literal-block"&gt;
https://loganchien.github.io/cert/
&lt;/pre&gt;
&lt;p&gt;This URL won't be redirected and work as expected.&lt;/p&gt;
</summary><category term="github"></category><category term="https"></category></entry><entry><title>Pelican and GitHub Pages</title><link href="https://loganchien.github.io/posts/2014/11/16/pelican-and-github-pages/" rel="alternate"></link><updated>2014-11-16T23:01:00+08:00</updated><author><name>Logan</name></author><id>tag:loganchien.github.io,2014-11-16:posts/2014/11/16/pelican-and-github-pages/</id><summary type="html">&lt;p&gt;&lt;a class="reference external" href="http://docs.getpelican.com"&gt;Pelican&lt;/a&gt; has built-in support for &lt;a class="reference external" href="https://pages.github.com"&gt;GitHub Pages&lt;/a&gt;.  However, I noticed that
the &lt;code&gt;ghp-import&lt;/code&gt; command might screw up the commit log if your GitHub
Pages and your Pelican source code share the same branch name.&lt;/p&gt;
&lt;p&gt;According to the document of &lt;a class="reference external" href="https://pages.github.com"&gt;GitHub Pages&lt;/a&gt;, the user pages should be
committed to &lt;code&gt;master&lt;/code&gt; branch (instead of &lt;code&gt;gh_pages&lt;/code&gt;.)  If you have
answered &lt;code&gt;master&lt;/code&gt; while &lt;code&gt;pelican-quickstart&lt;/code&gt; was asking for the
GitHub Page branch, then &lt;code&gt;ghp-import&lt;/code&gt; will automatically commit the
generated output to the &lt;code&gt;master&lt;/code&gt; branch.  Consequently, the git
repository will be screwed up.&lt;/p&gt;
&lt;p&gt;My solution is to create a &lt;code&gt;pelican-source&lt;/code&gt; branch for Pelican source
code, and commit the generated output to the &lt;code&gt;master&lt;/code&gt; branch.  This will
fix this issue without any problems.&lt;/p&gt;
</summary><category term="github"></category><category term="pelican"></category></entry><entry><title>SSL Certificate</title><link href="https://loganchien.github.io/posts/2014/11/15/ssl-certificate/" rel="alternate"></link><updated>2014-11-15T02:30:00+08:00</updated><author><name>Logan</name></author><id>tag:loganchien.github.io,2014-11-15:posts/2014/11/15/ssl-certificate/</id><summary type="html">&lt;p&gt;I would like to run &lt;a class="reference external" href="https://code.google.com/p/shellinabox/"&gt;shellinabox&lt;/a&gt; and my private blog system through HTTPS
protocol.  However, an SSL certificate is really expensive, thus I decided to
run our own &lt;strong&gt;certificate authority&lt;/strong&gt; and distribute my &lt;em&gt;cacert.pem&lt;/em&gt; through
&lt;a class="reference external" href="https://pages.github.com"&gt;GitHub Pages&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;In general, running a certificate authority requires three steps:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;Create a RSA public/private keys for the CA.  This step will create
&lt;code&gt;cacert.pem&lt;/code&gt; as well.  You should distribute the CA certificate via
some safe tunnel.&lt;/li&gt;
&lt;li&gt;For each service, create a &lt;em&gt;certificate request&lt;/em&gt; and send it to CA.&lt;/li&gt;
&lt;li&gt;The CA should sign the certificate request, and return it back.&lt;/li&gt;
&lt;li&gt;Install the CA-signed SSL certificate to HTTPS server (and etc.)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The OpenSSL package from Ubuntu has provide a simple script for us to
manage the certificates.  Let's start.&lt;/p&gt;
&lt;div class="section" id="create-a-certificate-authority"&gt;
&lt;h2&gt;Create a Certificate Authority&lt;/h2&gt;
&lt;p&gt;Create directory to save everything:&lt;/p&gt;
&lt;pre class="code bash literal-block"&gt;
&lt;span class="nv"&gt;$ &lt;/span&gt;mkdir MyCA
&lt;span class="nv"&gt;$ &lt;/span&gt;chmod &lt;span class="m"&gt;700&lt;/span&gt; MyCA
&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;cd &lt;/span&gt;MyCA
&lt;/pre&gt;
&lt;p&gt;Copy the tools:&lt;/p&gt;
&lt;pre class="code bash literal-block"&gt;
&lt;span class="nv"&gt;$ &lt;/span&gt;cp /usr/lib/ssl/misc/CA.pl .
&lt;span class="nv"&gt;$ &lt;/span&gt;cp /etc/ssl/openssl.cnf .
&lt;/pre&gt;
&lt;p&gt;Edit the configurations to fit your need, and finally create the certificate
for your CA:&lt;/p&gt;
&lt;pre class="code bash literal-block"&gt;
&lt;span class="nv"&gt;$ &lt;/span&gt;./CA.pl -newca
&lt;/pre&gt;
&lt;p&gt;By default, the &lt;code&gt;cacert.pem&lt;/code&gt; will be generated at
&lt;code&gt;demoCA/cacert.pem&lt;/code&gt;.  Install this certificate as an authority in your
browser.  You can also check the fingerprint with:&lt;/p&gt;
&lt;pre class="code bash literal-block"&gt;
&lt;span class="nv"&gt;$ &lt;/span&gt;openssl x509 -fingerprint -noout -in cacert.pem
&lt;span class="nv"&gt;$ &lt;/span&gt;openssl x509 -sha256 -fingerprint -noout -in cacert.pem
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="generate-certificates-for-your-service"&gt;
&lt;h2&gt;Generate Certificates for Your Service&lt;/h2&gt;
&lt;p&gt;To create the SSL certificate for your service:&lt;/p&gt;
&lt;pre class="code bash literal-block"&gt;
&lt;span class="c"&gt;# Create a certificate request
&lt;/span&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;./CA.pl -newreq

&lt;span class="c"&gt;# Sign a certificate request
&lt;/span&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;./CA.pl -sign
&lt;/pre&gt;
&lt;p&gt;The generated &lt;code&gt;newkey.pem&lt;/code&gt; and &lt;code&gt;newcert.pem&lt;/code&gt; are the private key
and the certificate respectively.&lt;/p&gt;
&lt;p&gt;Please notice that the &lt;code&gt;newkey.pem&lt;/code&gt; has been encrypted with a passpharse.
Under some situation, you have to decrypt it before installing the certificate
(e.g. Apache2).  Here's the command to decrypt the private key:&lt;/p&gt;
&lt;pre class="code bash literal-block"&gt;
&lt;span class="nv"&gt;$ &lt;/span&gt;openssl rsa -in newkey.pem -out newkey.nopass.pem
&lt;/pre&gt;
&lt;/div&gt;
</summary><category term="https"></category><category term="apache2"></category><category term="ssl"></category></entry></feed>